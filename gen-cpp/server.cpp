// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "PicSim.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "opencv2/opencv.hpp"
#include "opencv2/dnn.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include <opencv2/core/utils/trace.hpp>
#include <iostream>
#include "algorithm"
#include "vector"
#include "fstream"
using namespace cv;
using namespace cv::dnn;
using namespace std;

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

//reg_pic_num < 5000
#define REG_PIC_NUM 1000
#define MODEL_PROTOTXT "/Users/bytedance/code/sim_pic/gen-cpp/model/deploy.prototxt"
#define MODEL_BIN "/Users/bytedance/code/sim_pic/gen-cpp/model/bvlc_googlenet.caffemodel"
#define FEATURE_SIZE 1024
#define SIM_PIC_NUM 4

struct ImageInfo {
    float* feat;
    string name;
    float score;
    ImageInfo() {
        feat = NULL;
        name = "";
        score = 0.0f;
    }
};

bool cmp(ImageInfo* img1, ImageInfo* img2){
    return img1->score > img2->score;
}

class PicSimHandler : virtual public PicSimIf {
    protected:
        Net net;
        vector<ImageInfo* > infos;

    public:

        PicSimHandler() {
            // Your initialization goes here
            String modelTxt = MODEL_PROTOTXT;
            String modelBin = MODEL_BIN;
            CV_TRACE_FUNCTION();
            try {
                this->net = dnn::readNetFromCaffe(modelTxt, modelBin);
            }
            catch (cv::Exception& e) {
                std::cerr << "Exception: " << e.what() << std::endl;
                if (net.empty())
                {
                    cerr << "Can't load network" << std::endl;
                    exit(-1);
                }
            }
            std::ifstream file("/Users/bytedance/code/sim_pic/gen-cpp/imagelist.txt");
            for(int i = 0; i < REG_PIC_NUM; i++) {
                string filename;
                file >> filename;
                Mat img = imread(filename, 1);
                float* feat = get_feature(img);
                ImageInfo* info = new ImageInfo();
                info->feat = feat;
                info->name = filename;
                infos.push_back(info);
            }
            cout << "Server Is Ready..." << endl;
        }

        float dot_prod(float* vec1, float* vec2) {
            float sum = 0;
            for(int i = 0; i < FEATURE_SIZE; i++) {
                sum += vec1[i] * vec2[i];
            }
            return sum;
        }

        void get_sim_pics(std::vector<Image> & _return, const Image& img) {
            // Your implementation goes here
            unsigned char* data = (unsigned char*)((img.data).c_str());
            Mat raw_img(img.height, img.width, CV_8UC3);
            raw_img.data = data;
            float* feat = get_feature(raw_img);

            float feat_sum = dot_prod(feat, feat);
            for(int i = 0; i < infos.size(); i++) {
                float feat_sum1 = dot_prod(infos[i]->feat, infos[i]->feat);
                float dp = dot_prod(infos[i]->feat, feat);
                infos[i]->score = dp/sqrt(feat_sum)/sqrt(feat_sum1);
            }
            std::sort(infos.begin(), infos.end(), cmp);

            for(int i = 0; i < SIM_PIC_NUM; i++) {
                cout << infos[i]->score << endl;
                Mat tmp = imread(infos[i]->name, 1);
                Image ig;
                ig.width = tmp.cols;
                ig.height = tmp.rows;
                ig.channel = tmp.channels();
                size_t len = ig.width * ig.height * ig.channel;
                ig.data = string((char*)tmp.data, len);
                _return.push_back(ig);
            }
        }

        float* get_feature(Mat img) {
            Mat inputBlob = blobFromImage(img, 1.0f, Size(224, 224), Scalar(104, 117, 123), false);
            Mat feat;
            //CV_TRACE_REGION("forward");
            net.setInput(inputBlob, "data");
            feat = net.forward("pool5/drop_7x7_s1");
            Mat out = feat.reshape(1, 1);
            float* feature = new float[FEATURE_SIZE];
            for (int i = 0; i < FEATURE_SIZE; i++) {
                feature[i] = (float)out.at<float>(i);
            }
            return feature;
        }

};

int main(int argc, char **argv) {
    int port = 9090;
    ::apache::thrift::stdcxx::shared_ptr<PicSimHandler> handler(new PicSimHandler());
    ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new PicSimProcessor(handler));
    ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    return 0;
}

